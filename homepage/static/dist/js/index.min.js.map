{"version":3,"sources":["webpack://homepage/./homepage/static/src/ts/index/navigation.ts","webpack://homepage/./homepage/static/src/ts/index/header/loader.ts","webpack://homepage/./homepage/static/src/ts/index/header/image.ts","webpack://homepage/./homepage/static/src/ts/index/header/header.ts"],"names":["document","addEventListener","$navbarBurgers","Array","prototype","slice","call","querySelectorAll","length","forEach","el","target","dataset","$target","getElementById","classList","toggle","threeLink","animeLink","this","loadThree","Promise","resolve","reject","threeId","getAttribute","undefined","Error","threeHref","threeElement","createElement","onload","id","src","parentNode","insertBefore","nextSibling","loadAnime","animeId","animeHref","animeElement","imageElement","loadTextureBehindAttribute","attribute","textureLoader","THREE","TextureLoader","load","loadCubemapBehindAttribute","CubeTextureLoader","setPath","parallaxScene","width","clientWidth","height","clientHeight","camera","PerspectiveCamera","position","z","renderer","WebGLRenderer","antialias","alpha","setSize","canvas","domElement","style","opacity","background","transition","top","left","diffuseTextureLoader","depthTextureLoader","cubemapTextureLoader","fetch","text","fragmentShader","vertexShader","shaderMaterial","ShaderMaterial","uniforms","mouseX","value","mouseY","scrollOffset","imageTexture","depthTexture","cubemapTexture","scene","Scene","geometry","PlaneGeometry","mesh","Mesh","add","ParallaxScene","show","hide","image","lastOrientation","requestAnimationFrame","window","render","updateViewportAspectRatio","aspect","naturalWidth","naturalHeight","updateProjectionMatrix","vFOV","MathUtils","degToRad","fov","maxHeight","Math","tan","scale","set","reactToMouseMove","event","rect","getBoundingClientRect","bottom","x","clientX","y","clientY","anime","targets","duration","easing","update","reactToTouchMove","touches","reactToScroll","min","max","scrollY","innerHeight","bind","display","removeEventListener","querySelector","threeLoader","ThreeLoader","parallaxImageElements","parallaxImages","from","map","element","ParallaxImage","updateWindowDimensions","parallaxImage"],"mappings":"AAAAA,SAASC,iBAAiB,oBAAoB,WAE5C,IAAMC,EAAiBC,MAAMC,UAAUC,MAAMC,KAAKN,SAASO,iBAAiB,kBAAmB,GAG3FL,EAAeM,OAAS,GAG1BN,EAAeO,SAAQ,SAACC,GACtBA,EAAGT,iBAAiB,SAAS,WAG3B,IAAMU,EAASD,EAAGE,QAAQD,OACpBE,EAAUb,SAASc,eAAeH,GAGxCD,EAAGK,UAAUC,OAAO,aACpBH,EAAQE,UAAUC,OAAO,sB,o2CCFjC,aAII,WACIC,EACAC,GAEAC,KAAKF,UAAYA,EACjBE,KAAKD,UAAYA,EAyFzB,OAhFiB,YAAAE,UAAb,W,8EACI,MAAO,CAAP,EAAO,IAAIC,SAAQ,SAACC,EAASC,GACzB,IAAMC,EAAU,EAAKP,UAAUQ,aAAa,gBAC5BC,IAAZF,GACAD,EAAO,IAAII,MACP,wDAIR,IAAMC,EAAY,EAAKX,UAAUQ,aAAa,aAC5BC,IAAdE,GACAL,EAAO,IAAII,MACP,qDAKR,IAAIE,EACA7B,SAASc,eAAeU,GACP,OAAjBK,IAMJA,EAAe7B,SAAS8B,cAAc,WACzBC,OAAS,WAClBT,EAAQO,IAEZA,EAAaG,GAAKR,EAClBK,EAAaI,IAAML,EAEnB,EAAKX,UAAUiB,WAAWC,aACtBN,EAAc,EAAKZ,UAAUmB,cAb7Bd,EAAQO,cAwBP,YAAAQ,UAAb,W,8EACI,MAAO,CAAP,EAAO,IAAIhB,SAAQ,SAACC,EAASC,GACzB,IAAMe,EAAU,EAAKpB,UAAUO,aAAa,gBAC5BC,IAAZY,GACAf,EAAO,IAAII,MACP,wDAIR,IAAMY,EAAY,EAAKrB,UAAUO,aAAa,aAC5BC,IAAda,GACAhB,EAAO,IAAII,MACP,qDAKR,IAAIa,EACAxC,SAASc,eAAewB,GACP,OAAjBE,IAKJA,EAAexC,SAAS8B,cAAc,WACzBC,OAAS,WAClBT,EAAQkB,IAEZA,EAAaR,GAAKM,EAClBE,EAAaP,IAAMM,EAEnB,EAAKrB,UAAUgB,WAAWC,aACtBK,EAAc,EAAKtB,UAAUkB,cAZ7Bd,EAAQkB,cAgBxB,EAlGA,G,60CCEA,aAKI,WAAmBC,GACftB,KAAKsB,aAAeA,EA4H5B,OAzHiB,YAAAC,2BAAb,SAAwCC,G,8EACpC,MAAO,CAAP,EAAO,IAAItB,SAAQ,SAACC,EAASC,GACzB,IAAMU,EAAM,EAAKQ,aAAahB,aAAakB,GAC3C,GAAY,OAARV,EAOJ,IAAMW,GAAgB,IAAIC,MAAMC,eAC3BC,KAAKd,GAAK,WACPX,EAAQsB,WARZrB,EAAO,IAAII,MAAM,2FAEGgB,EAAS,oCAW5B,YAAAK,2BAAb,SAAwCL,G,8EACpC,MAAO,CAAP,EAAO,IAAItB,SAAQ,SAACC,EAASC,GACzB,IAAMU,EAAM,EAAKQ,aAAahB,aAAakB,GAC3C,GAAY,OAARV,EAOJ,IAAMW,GAAgB,IAAIC,MAAMI,mBAC3BC,QAAQjB,GAGRc,KAAK,CACF,SACA,SACA,SACA,SACA,SACA,WACD,WACCzB,EAAQsB,WAlBZrB,EAAO,IAAII,MAAM,2FAEGgB,EAAS,oCAqB5B,YAAAI,KAAb,W,0HACI,YAA2BrB,IAAvBP,KAAKgC,cACL,KAGEC,EAAQjC,KAAKsB,aAAaY,YAC1BC,EAASnC,KAAKsB,aAAac,cAC3BC,EAAS,IAAIX,MAAMY,kBACrB,GAAIL,EAAQE,EAAQ,EAAG,MAEpBI,SAASC,EAAI,KAEdC,EAAW,IAAIf,MAAMgB,cAAc,CACrCC,WAAW,EACXC,OAAO,KAEFC,QAAQZ,EAAOE,IAClBW,EAASL,EAASM,YAEjBC,MAAMC,QAAU,IACvBH,EAAOE,MAAME,WAAa,cAC1BJ,EAAOE,MAAMG,WAAa,aAC1BL,EAAOE,MAAMT,SAAW,WACxBO,EAAOE,MAAMI,IAAM,IACnBN,EAAOE,MAAMK,KAAO,IAES,GAAMrD,KAC9BuB,2BAA2B,S,OACL,OAFrB+B,EAAuB,SAEF,GAAMtD,KAC5BuB,2BAA2B,4B,OACH,OAFvBgC,EAAqB,SAEE,GAAMvD,KAC9B6B,2BAA2B,+B,OAGF,OAJxB2B,EAAuB,SAIC,GAAMC,MAAM,kD,OAAnB,SAAO,SAA8DC,Q,OAChE,OADtBC,EAAiB,SACK,GAAMF,MAAM,kD,OAAnB,SAAO,SAA8DC,Q,OAgC1F,OAhCME,EAAe,SAEfC,EAAiB,IAAInC,MAAMoC,eAAe,CAC5CC,SAAU,CACNC,OAAQ,CAACC,MAAO,GAChBC,OAAQ,CAACD,MAAO,GAChBE,aAAc,CAACF,MAAO,GACtBG,aAAc,CAACH,MAAOX,GACtBe,aAAc,CAACJ,MAAOV,GACtBe,eAAgB,CAACL,MAAOT,IAE5BI,aAAY,EACZD,eAAc,IAEZY,EAAQ,IAAI7C,MAAM8C,MAClBC,EAAW,IAAI/C,MAAMgD,cAAc,EAAG,GACtCC,EAAO,IAAIjD,MAAMkD,KAAKH,EAAUZ,GACtCU,EAAMM,IAAIF,GAEV3E,KAAKgC,cAAgB,IAAI8C,EACrB9E,KAAKsB,aACLwB,EACAT,EACAI,EACAa,EACAC,EACAM,EACAU,EACAE,EACAE,GAGJ,YAGG,YAAAI,KAAP,W,MACsB,QAAlB,EAAA/E,KAAKgC,qBAAa,SAAE+C,QAGjB,YAAAC,KAAP,W,MACsB,QAAlB,EAAAhF,KAAKgC,qBAAa,SAAEgD,QAE5B,EAlIA,GAwIA,aAcI,WACIC,EACAnC,EACAT,EACAI,EACAa,EACAC,EACAM,EACAU,EACAE,EACAE,GAZJ,KAAAO,gBAAiD,KAc7ClF,KAAKiF,MAAQA,EACbjF,KAAK8C,OAASA,EACd9C,KAAKqC,OAASA,EACdrC,KAAKyC,SAAWA,EAChBzC,KAAKsD,qBAAuBA,EAC5BtD,KAAKuD,mBAAqBA,EAC1BvD,KAAK6D,eAAiBA,EACtB7D,KAAKuE,MAAQA,EACbvE,KAAKyE,SAAWA,EAChBzE,KAAK2E,KAAOA,EAyIpB,OAtIY,YAAAQ,sBAAR,sBACIC,OAAOD,uBAAsB,WACzB,EAAK1C,SAAS4C,OAAO,EAAKd,MAAO,EAAKlC,YAItC,YAAAiD,0BAAR,WACItF,KAAKqC,OAAOkD,OACRvF,KAAKiF,MAAMO,aAAexF,KAAKiF,MAAMQ,cACzCzF,KAAKqC,OAAOqD,yBACZ,IAAMC,EAAOjE,MAAMkE,UAAUC,SAAS7F,KAAKqC,OAAOyD,KAC5CC,EAAY,EAAIC,KAAKC,IAAIN,EAAO,GAAK3F,KAAKqC,OAAOE,SAASC,EAG1DL,EAAS4D,EACT9D,EAAQ8D,GAFV/F,KAAKiF,MAAMQ,cAAgBzF,KAAKiF,MAAMO,cAG1CxF,KAAK2E,KAAKuB,MAAMC,IAAIlE,EAAOE,EAAQ,GACnCnC,KAAKmF,yBAGD,YAAAiB,iBAAR,SAAyBC,GAAzB,WACUC,EAAOtG,KAAK8C,OAAOyD,wBACzB,KAAID,EAAKE,OAAS,GAAlB,CACA,IAAMC,GAAKJ,EAAMK,QAAUJ,EAAKjD,MAAQiD,EAAKrE,MACvC0E,GAAKN,EAAMO,QAAUN,EAAKlD,KAAOkD,EAAKnE,OAC5C0E,MAAM,CACFC,QAAS9G,KAAK6D,eAAeE,SAASC,OACtCC,MAAOwC,EACPM,SAAU,IACVC,OAAQ,cACRC,OAAQ,WAAM,SAAK9B,2BAEvB0B,MAAM,CACFC,QAAS9G,KAAK6D,eAAeE,SAASG,OACtCD,MAAO0C,EACPI,SAAU,IACVC,OAAQ,cACRC,OAAQ,WAAM,SAAK9B,6BAInB,YAAA+B,iBAAR,SAAyBb,GAAzB,WACUC,EAAOtG,KAAK8C,OAAOyD,wBACzB,KAAID,EAAKE,OAAS,GAAlB,CACA,IAAMC,GAAKJ,EAAMc,QAAQ,GAAGT,QAAUJ,EAAKjD,MAAQiD,EAAKrE,MAClD0E,GAAKN,EAAMc,QAAQ,GAAGP,QAAUN,EAAKlD,KAAOkD,EAAKnE,OACvD0E,MAAM,CACFC,QAAS9G,KAAK6D,eAAeE,SAASC,OACtCC,MAAOwC,EACPM,SAAU,IACVC,OAAQ,cACRC,OAAQ,WAAM,SAAK9B,2BAEvB0B,MAAM,CACFC,QAAS9G,KAAK6D,eAAeE,SAASG,OACtCD,MAAO0C,EACPI,SAAU,IACVC,OAAQ,cACRC,OAAQ,WAAM,SAAK9B,6BAInB,YAAAiC,cAAR,sBAEI,KADapH,KAAK8C,OAAOyD,wBAChBC,OAAS,GAAlB,CACA,IAAMrC,EAAe6B,KAAKqB,IAAIrB,KAAKsB,IAAWlC,OAAOmC,QAAUnC,OAAOoC,YAA/B,GAA6C,GAAI,IACxFX,MAAM,CACFC,QAAS9G,KAAK6D,eAAeE,SAASI,aACtCF,MAAOE,EACP4C,SAAU,IACVC,OAAQ,cACRC,OAAQ,WAAM,SAAK9B,6BAIpB,YAAAJ,KAAP,WACmC,OAA3B/E,KAAK8C,OAAO/B,aACZf,KAAKiF,MAAMlE,WAAWC,aAClBhB,KAAK8C,OAAQ9C,KAAKiF,MAAMhE,aAE5BjB,KAAKyC,SAASI,QACV7C,KAAK8C,OAAOZ,YACZlC,KAAK8C,OAAOV,cAEhBpC,KAAK8C,OAAOE,MAAMC,QAAU,KAEhCmC,OAAOtG,iBACH,SACAkB,KAAKsF,0BAA0BmC,KAAKzH,OACpC,GAEJnB,SAASC,iBACL,YACAkB,KAAKoG,iBAAiBqB,KAAKzH,OAC3B,GAEJnB,SAASC,iBACL,YACAkB,KAAKkH,iBAAiBO,KAAKzH,OAC3B,GAEJoF,OAAOtG,iBACH,SACAkB,KAAKoH,cAAcK,KAAKzH,OACxB,GAEJA,KAAKsF,4BACLtF,KAAKmF,yBAGF,YAAAH,KAAP,WACIhF,KAAKiF,MAAMjC,MAAM0E,QAAU,eAC3B1H,KAAK8C,OAAOE,MAAM0E,QAAU,OAC5BtC,OAAOuC,oBACH,SACA3H,KAAKsF,0BAA0BmC,KAAKzH,OACpC,GAEJnB,SAAS8I,oBACL,YACA3H,KAAKoG,iBAAiBqB,KAAKzH,OAC3B,GAEJnB,SAAS8I,oBACL,YACA3H,KAAKkH,iBAAiBO,KAAKzH,OAC3B,GAEJoF,OAAOuC,oBACH,SACA3H,KAAKoH,cAAcK,KAAKzH,OACxB,IAGZ,EA5KA,G,60CCjHAnB,SAASC,iBAAiB,oBAAoB,qD,kEAqB1C,OApBMgB,EAA6BjB,SAC9B+I,cAAc,iCACb7H,EAA6BlB,SAC9B+I,cAAc,iCAEbC,EAAc,IAAIC,EAAYhI,EAAWC,GACzCgI,EAAwBlJ,SACzBO,iBAAmC,gBAClC4I,EAAiBhJ,MAAMiJ,KAAKF,GAC7BG,KAAI,SAACC,GAAY,WAAIC,EAAcD,MAWxC,IATME,EAAyB,qD,4DAC3B,SAAMR,EAAY5H,a,OAClB,OADA,SACA,GAAM4H,EAAY3G,a,OAAlB,S,IAC0B,EAAA8G,E,wBAAA,WACtB,IADKM,EAAa,MACE1G,QADgB,M,OACpC,SACA0G,EAAcvD,O,wBAFQ,I,iDAM9B,SACAK,OAAOtG,iBAAiB,SAAUuJ,GAAwB,G","file":"index.min.js","sourcesContent":["document.addEventListener('DOMContentLoaded', () => {\n  // Get all \"navbar-burger\" elements\n  const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0)\n\n  // Check if there are any navbar burgers\n  if ($navbarBurgers.length > 0) {\n\n    // Add a click event on each of them\n    $navbarBurgers.forEach((el: any) => {\n      el.addEventListener('click', () => {\n\n        // Get the target from the \"data-target\" attribute\n        const target = el.dataset.target\n        const $target = document.getElementById(target)\n\n        // Toggle the \"is-active\" class on both the \"navbar-burger\" and the \"navbar-menu\"\n        el.classList.toggle('is-active')\n        $target.classList.toggle('is-active')\n\n      })\n    })\n  }\n})\n","/**\n * A lazy loader for the THREE.js script.\n *\n * Usage:\n *\n * ```typescript\n * const linkElement = <HTMLLinkElement>document\n *     .querySelector('link[rel=\"parallax-three-js\"]')\n * // TODO: Check if linkElement actually exists\n * const loader = new ThreeLoader(linkElement)\n *     .load(() => {\n *         // Do something on load\n *     })\n * ```\n */\nexport class ThreeLoader {\n    private threeLink: HTMLLinkElement\n    private animeLink: HTMLLinkElement\n\n    public constructor(\n        threeLink: HTMLLinkElement,\n        animeLink: HTMLLinkElement\n    ) {\n        this.threeLink = threeLink\n        this.animeLink = animeLink\n    }\n\n    /**\n     * Load THREE.js into a script element.\n     *\n     * The script element is placed below the given link element.\n     * See index.ts for a usage example.\n     */\n    public async loadThree(): Promise<HTMLScriptElement> {\n        return new Promise((resolve, reject) => {\n            const threeId = this.threeLink.getAttribute('data-id')\n            if (threeId === undefined) {\n                reject(new Error(\n                    'The link element has to supply a data-id attribute!'\n                ))\n            }\n\n            const threeHref = this.threeLink.getAttribute('href')\n            if (threeHref === undefined) {\n                reject(new Error(\n                    'The link element has to supply a href attribute!'\n                ))\n            }\n\n            // Check if there is already a THREE.js script element.\n            let threeElement = <HTMLScriptElement>\n                document.getElementById(threeId)\n            if (threeElement !== null) {\n                resolve(threeElement)\n                return\n            }\n\n            // If not, create a new one.\n            threeElement = document.createElement('script')\n            threeElement.onload = () => {\n                resolve(threeElement)\n            }\n            threeElement.id = threeId\n            threeElement.src = threeHref\n            // Insert THREE.js after the link element.\n            this.threeLink.parentNode.insertBefore(\n                threeElement, this.threeLink.nextSibling\n            )\n        })\n    }\n\n    /**\n     * Load anime.js into a script element.\n     *\n     * The script element is placed below the given link element.\n     * See index.ts for a usage example.\n     */\n    public async loadAnime(): Promise<HTMLScriptElement> {\n        return new Promise((resolve, reject) => {\n            const animeId = this.animeLink.getAttribute('data-id')\n            if (animeId === undefined) {\n                reject(new Error(\n                    'The link element has to supply a data-id attribute!'\n                ))\n            }\n\n            const animeHref = this.animeLink.getAttribute('href')\n            if (animeHref === undefined) {\n                reject(new Error(\n                    'The link element has to supply a href attribute!'\n                ))\n            }\n\n            // Check if there is already a THREE.js script element.\n            let animeElement = <HTMLScriptElement>\n                document.getElementById(animeId)\n            if (animeElement !== null) {\n                resolve(animeElement)\n                return\n            }\n\n            animeElement = document.createElement('script')\n            animeElement.onload = () => {\n                resolve(animeElement)\n            }\n            animeElement.id = animeId\n            animeElement.src = animeHref\n            // Insert THREE.js after the link element.\n            this.animeLink.parentNode.insertBefore(\n                animeElement, this.animeLink.nextSibling\n            )\n        })\n    }\n}\n","/**\n * The lazily imported THREE.js library.\n *\n * THREE is loaded lazily and only on devices exceeding a given\n * maximum width. It will not be included as a module to reduce the\n * file size of this script.\n */\ndeclare var THREE: any\n\n/**\n * The anime library, for smooth animations of the parallax effect.\n */\ndeclare var anime: any\n\n/**\n * A parallax image, driven by THREE.js.\n */\nexport class ParallaxImage {\n    imageElement: HTMLImageElement\n\n    parallaxScene?: ParallaxScene\n\n    public constructor(imageElement: HTMLImageElement) {\n        this.imageElement = imageElement\n    }\n\n    public async loadTextureBehindAttribute(attribute: string): Promise<any> {\n        return new Promise((resolve, reject) => {\n            const src = this.imageElement.getAttribute(attribute)\n            if (src === null) {\n                reject(new Error(`\n                    The image element must include\n                    an attribute \"${attribute}\"!\n                `))\n                return\n            }\n            const textureLoader = new THREE.TextureLoader()\n                .load(src, () => {\n                    resolve(textureLoader)\n                })\n        })\n    }\n\n    public async loadCubemapBehindAttribute(attribute: string): Promise<any> {\n        return new Promise((resolve, reject) => {\n            const src = this.imageElement.getAttribute(attribute)\n            if (src === null) {\n                reject(new Error(`\n                    The image element must include\n                    an attribute \"${attribute}\"!\n                `))\n                return\n            }\n            const textureLoader = new THREE.CubeTextureLoader()\n                .setPath(src)\n                // Use: https://matheowis.github.io/HDRI-to-CubeMap/\n                // to convert an HDRI to a cubemap\n                .load([\n                    \"px.png\",\n                    \"nx.png\",\n                    \"py.png\",\n                    \"ny.png\",\n                    \"pz.png\",\n                    \"nz.png\"\n                ], () => {\n                    resolve(textureLoader)\n                })\n        })\n    }\n\n    public async load() {\n        if (this.parallaxScene !== undefined) {\n            return\n        }\n\n        const width = this.imageElement.clientWidth\n        const height = this.imageElement.clientHeight\n        const camera = new THREE.PerspectiveCamera(\n            45, width / height, 1, 1000\n        )\n        camera.position.z = 200\n\n        const renderer = new THREE.WebGLRenderer({\n            antialias: false,\n            alpha: false\n        })\n        renderer.setSize(width, height)\n        const canvas = renderer.domElement\n\n        canvas.style.opacity = '0'\n        canvas.style.background = 'transparent'\n        canvas.style.transition = 'opacity 1s'\n        canvas.style.position = 'absolute'\n        canvas.style.top = '0'\n        canvas.style.left = '0'\n\n        const diffuseTextureLoader = await this\n            .loadTextureBehindAttribute('src')\n        const depthTextureLoader = await this\n            .loadTextureBehindAttribute('data-parallax-depth-map')\n        const cubemapTextureLoader = await this\n            .loadCubemapBehindAttribute('data-parallax-cubemap-path')\n\n        // Load the fragment and vertex shader\n        const fragmentShader = await (await fetch('/static/src/ts/index/header/shaders/frag.glsl')).text()\n        const vertexShader = await (await fetch('/static/src/ts/index/header/shaders/vert.glsl')).text()\n\n        const shaderMaterial = new THREE.ShaderMaterial({\n            uniforms: {\n                mouseX: {value: 0},\n                mouseY: {value: 0},\n                scrollOffset: {value: 0},\n                imageTexture: {value: diffuseTextureLoader},\n                depthTexture: {value: depthTextureLoader},\n                cubemapTexture: {value: cubemapTextureLoader}\n            },\n            vertexShader,\n            fragmentShader\n        })\n        const scene = new THREE.Scene()\n        const geometry = new THREE.PlaneGeometry(1, 1)\n        const mesh = new THREE.Mesh(geometry, shaderMaterial)\n        scene.add(mesh)\n\n        this.parallaxScene = new ParallaxScene(\n            this.imageElement,\n            canvas,\n            camera,\n            renderer,\n            diffuseTextureLoader,\n            depthTextureLoader,\n            shaderMaterial,\n            scene,\n            geometry,\n            mesh\n        )\n\n        return\n    }\n\n    public show(): void {\n        this.parallaxScene?.show()\n    }\n\n    public hide(): void {\n        this.parallaxScene?.hide()\n    }\n}\n\n\n/**\n * A parallax scene, driven by THREE.js.\n */\nclass ParallaxScene {\n    image: HTMLImageElement\n    canvas: HTMLCanvasElement\n    camera: any\n    renderer: any\n    diffuseTextureLoader: any\n    depthTextureLoader: any\n    shaderMaterial: any\n    scene: any\n    geometry: any\n    mesh: any\n\n    lastOrientation: DeviceOrientationEvent | null = null\n\n    public constructor(\n        image: HTMLImageElement,\n        canvas: HTMLCanvasElement,\n        camera: any,\n        renderer: any,\n        diffuseTextureLoader: any,\n        depthTextureLoader: any,\n        shaderMaterial: any,\n        scene: any,\n        geometry: any,\n        mesh: any\n    ) {\n        this.image = image\n        this.canvas = canvas\n        this.camera = camera\n        this.renderer = renderer\n        this.diffuseTextureLoader = diffuseTextureLoader\n        this.depthTextureLoader = depthTextureLoader\n        this.shaderMaterial = shaderMaterial\n        this.scene = scene\n        this.geometry = geometry\n        this.mesh = mesh\n    }\n\n    private requestAnimationFrame(): void {\n        window.requestAnimationFrame(() => {\n            this.renderer.render(this.scene, this.camera)\n        })\n    }\n\n    private updateViewportAspectRatio(): void {\n        this.camera.aspect =\n            this.image.naturalWidth / this.image.naturalHeight\n        this.camera.updateProjectionMatrix()\n        const vFOV = THREE.MathUtils.degToRad(this.camera.fov)\n        const maxHeight = 2 * Math.tan(vFOV / 2) * this.camera.position.z\n        const imageAspect =\n            this.image.naturalHeight / this.image.naturalWidth\n        const height = maxHeight\n        const width = maxHeight * imageAspect\n        this.mesh.scale.set(width, height, 1)\n        this.requestAnimationFrame()\n    }\n\n    private reactToMouseMove(event: MouseEvent): void {\n        const rect = this.canvas.getBoundingClientRect()\n        if (rect.bottom < 0) return;\n        const x = (event.clientX - rect.left) / rect.width\n        const y = (event.clientY - rect.top) / rect.height\n        anime({\n            targets: this.shaderMaterial.uniforms.mouseX,\n            value: x,\n            duration: 1000,\n            easing: 'easeOutQuad',\n            update: () => this.requestAnimationFrame()\n        })\n        anime({\n            targets: this.shaderMaterial.uniforms.mouseY,\n            value: y,\n            duration: 1000,\n            easing: 'easeOutQuad',\n            update: () => this.requestAnimationFrame()\n        })\n    }\n\n    private reactToTouchMove(event: TouchEvent): void {\n        const rect = this.canvas.getBoundingClientRect()\n        if (rect.bottom < 0) return;\n        const x = (event.touches[0].clientX - rect.left) / rect.width\n        const y = (event.touches[0].clientY - rect.top) / rect.height\n        anime({\n            targets: this.shaderMaterial.uniforms.mouseX,\n            value: x,\n            duration: 1000,\n            easing: 'easeOutQuad',\n            update: () => this.requestAnimationFrame()\n        })\n        anime({\n            targets: this.shaderMaterial.uniforms.mouseY,\n            value: y,\n            duration: 1000,\n            easing: 'easeOutQuad',\n            update: () => this.requestAnimationFrame()\n        })\n    }\n\n    private reactToScroll(): void {\n        const rect = this.canvas.getBoundingClientRect()\n        if (rect.bottom < 0) return;\n        const scrollOffset = Math.min(Math.max(0.5 * (window.scrollY / window.innerHeight), 0), 0.1)\n        anime({\n            targets: this.shaderMaterial.uniforms.scrollOffset,\n            value: scrollOffset,\n            duration: 200,\n            easing: 'easeOutQuad',\n            update: () => this.requestAnimationFrame()\n        })\n    }\n\n    public show(): void {\n        if (this.canvas.parentNode === null) {\n            this.image.parentNode.insertBefore(\n                this.canvas, this.image.nextSibling\n            )\n            this.renderer.setSize(\n                this.canvas.clientWidth,\n                this.canvas.clientHeight\n            )\n            this.canvas.style.opacity = '1'\n        }\n        window.addEventListener(\n            'resize',\n            this.updateViewportAspectRatio.bind(this),\n            true\n        )\n        document.addEventListener(\n            'mousemove',\n            this.reactToMouseMove.bind(this),\n            true\n        )\n        document.addEventListener(\n            'touchmove',\n            this.reactToTouchMove.bind(this),\n            true\n        )\n        window.addEventListener(\n            'scroll', \n            this.reactToScroll.bind(this),\n            true\n        );\n        this.updateViewportAspectRatio()\n        this.requestAnimationFrame()\n    }\n\n    public hide(): void {\n        this.image.style.display = 'inline-block'\n        this.canvas.style.display = 'none'\n        window.removeEventListener(\n            'resize',\n            this.updateViewportAspectRatio.bind(this),\n            true\n        )\n        document.removeEventListener(\n            'mousemove',\n            this.reactToMouseMove.bind(this),\n            true\n        )\n        document.removeEventListener(\n            'touchmove',\n            this.reactToTouchMove.bind(this),\n            true\n        )\n        window.removeEventListener(\n            'scroll',\n            this.reactToScroll.bind(this),\n            true\n        )\n    }\n}\n","/**\n * Author: Philipp Matthes\n *\n * This module is used for a parallax effect on images.\n *\n * It uses THREE.js (https://threejs.org/) on a canvas\n * together with an image and a depth map to apply\n * parallax occlusion mapping, similar to the\n * 3Dify app (https://github.com/3dify-app).\n *\n * Usage:\n *\n * ```html\n * <!-- Somewhere in your html --!>\n * <img ... src=\"path/to/preview.webp\"\n *          class=\"parallax\"\n *          data-parallax-depth-map=\"path/to/preview-depth.webp\">\n * <!-- Preferably at the bottom of your body element --!>\n * <link rel=\"parallax-three-js\"\n *       href=\"path/to/three.min.js\"\n *       data-id=\"id-of-the-lazyloaded-three-script-element\">\n * <!-- THREE.js will be loaded lazily to this location --!>\n * ```\n *\n * Notes:\n * - The srcset attribute is not supported.\n * - The image element gets lazily replaced (only on devices\n * wider than 1023 pixels) by a canvas which will render a\n * THREE.js parallax scene with the given depth map.\n * - THREE.js and the parallax effect is only loaded, when the\n * screen exceeds mobile device width of 1023 pixels. This also\n * applies to screen resizing events and not only the initial\n * page load.\n */\n\n\nimport { ThreeLoader } from './loader'\nimport { ParallaxImage } from './image'\n\n\ndocument.addEventListener('DOMContentLoaded', async () => {\n    const threeLink = <HTMLLinkElement>document\n        .querySelector('link[rel=\"parallax-three-js\"]')\n    const animeLink = <HTMLLinkElement>document\n        .querySelector('link[rel=\"parallax-anime-js\"]')\n\n    const threeLoader = new ThreeLoader(threeLink, animeLink)\n    const parallaxImageElements = document\n        .querySelectorAll<HTMLImageElement>('img.parallax')\n    const parallaxImages = Array.from(parallaxImageElements)\n        .map((element) => new ParallaxImage(element))\n\n    const updateWindowDimensions = async () => {\n        await threeLoader.loadThree()\n        await threeLoader.loadAnime()\n        for (let parallaxImage of parallaxImages) {\n            await parallaxImage.load()\n            parallaxImage.show()\n        }\n    }\n\n    await updateWindowDimensions()\n    window.addEventListener('resize', updateWindowDimensions, false)\n})\n\n"],"sourceRoot":""}