{"version":3,"sources":["webpack://homepage/./homepage/static/src/ts/parallax/loader.ts","webpack://homepage/./homepage/static/src/ts/parallax/image.ts","webpack://homepage/./homepage/static/src/ts/parallax/index.ts","webpack://homepage/./homepage/static/src/ts/apps.ts"],"names":["threeLink","this","load","Promise","resolve","reject","id","getAttribute","undefined","Error","href","threeElement","document","getElementById","createElement","onload","src","parentNode","insertBefore","nextSibling","imageElement","loadTextureBehindAttribute","attribute","textureLoader","THREE","TextureLoader","console","log","parallaxScene","width","clientWidth","height","clientHeight","camera","PerspectiveCamera","position","z","diffuseTextureLoader","depthTextureLoader","renderer","WebGLRenderer","antialias","alpha","setSize","canvas","domElement","shaderMaterial","ShaderMaterial","uniforms","mouseX","value","mouseY","scrollOffset","texture","depthTexture","vertexShader","fragmentShader","scene","Scene","geometry","PlaneBufferGeometry","mesh","Mesh","add","ParallaxScene","show","hide","image","requestAnimationFrame","window","render","updateViewportAspectRatio","aspect","naturalWidth","naturalHeight","updateProjectionMatrix","vFOV","Math","degToRad","fov","maxHeight","tan","scale","set","reactToMouseMove","event","rect","getBoundingClientRect","x","max","min","clientX","left","y","clientY","top","style","transform","display","addEventListener","bind","removeEventListener","querySelector","threeLoader","ThreeLoader","parallaxImageElements","querySelectorAll","parallaxImages","Array","from","map","element","ParallaxImage","updateWindowDimensions","documentElement","parallaxImage","macbookContainer","macbookCodeContainer","preview","ctx","getContext","frame","Image","frameURL","index","clearRect","drawImage","hasPreloadedFrames","updateCurrentPeerbridgeFrame","progress","innerHeight","i","r","onerror","frameIndex","round","updateCodeScroll","scrollTop","updateDeviceWidth"],"mappings":"uBAeA,aAGI,WAAmBA,GACfC,KAAKD,UAAYA,EA8CzB,OArCiB,YAAAE,KAAb,W,6mCACI,MAAO,CAAP,EAAO,IAAIC,SAAQ,SAACC,EAASC,GACzB,IAAMC,EAAK,EAAKN,UAAUO,aAAa,gBAC5BC,IAAPF,GACAD,EAAO,IAAII,MACP,wDAIR,IAAMC,EAAO,EAAKV,UAAUO,aAAa,aAC5BC,IAATE,GACAL,EAAO,IAAII,MACP,qDAKR,IAAIE,EACAC,SAASC,eAAeP,GACP,OAAjBK,IAMJA,EAAeC,SAASE,cAAc,WACzBC,OAAS,WAClBX,EAAQO,IAEZA,EAAaL,GAAKA,EAClBK,EAAaK,IAAMN,EAEnB,EAAKV,UAAUiB,WAAWC,aACtBP,EAAc,EAAKX,UAAUmB,cAb7Bf,EAAQO,W,gSAiBxB,EAlDA,G,60CCkCA,aAKI,WAAmBS,GACfnB,KAAKmB,aAAeA,EAiF5B,OA9EiB,YAAAC,2BAAb,SAAwCC,G,8EACpC,MAAO,CAAP,EAAO,IAAInB,SAAQ,SAACC,EAASC,GACzB,IAAMW,EAAM,EAAKI,aAAab,aAAae,GAC3C,GAAY,OAARN,EAOJ,IAAMO,GAAgB,IAAIC,MAAMC,eAC3BvB,KAAKc,GAAK,WACPU,QAAQC,IAAI,yBAAyBX,GACrCZ,EAAQmB,WATZlB,EAAO,IAAII,MAAM,2FAEGa,EAAS,oCAa5B,YAAApB,KAAb,W,oHACI,YAA2BM,IAAvBP,KAAK2B,cACL,KAGEC,EAAQ5B,KAAKmB,aAAaU,YAC1BC,EAAS9B,KAAKmB,aAAaY,cAC3BC,EAAS,IAAIT,MAAMU,kBACrB,GAAIL,EAAQE,EAAQ,EAAG,MAEpBI,SAASC,EAAI,IACS,GAAMnC,KAC9BoB,2BAA2B,S,OACL,OAFrBgB,EAAuB,SAEF,GAAMpC,KAC5BoB,2BAA2B,4B,OAmChC,OApCMiB,EAAqB,UAErBC,EAAW,IAAIf,MAAMgB,cAAc,CACrCC,WAAW,EACXC,OAAO,KAEFC,QAAQd,EAAOE,GAClBa,EAASL,EAASM,WAClBC,EAAiB,IAAItB,MAAMuB,eAAe,CAC5CC,SAAU,CACNC,OAAQ,CAACC,MAAO,GAChBC,OAAQ,CAACD,MAAO,GAChBE,aAAc,CAACF,MAAO,GACtBG,QAAS,CAACH,MAAOb,GACjBiB,aAAc,CAACJ,MAAOZ,IAE1BiB,aA9FiB,6JA+FjBC,eAlFmB,8rBAoFjBC,EAAQ,IAAIjC,MAAMkC,MAClBC,EAAW,IAAInC,MAAMoC,oBAAoB,EAAG,GAC5CC,EAAO,IAAIrC,MAAMsC,KAAKH,EAAUb,GACtCW,EAAMM,IAAIF,GAEV5D,KAAK2B,cAAgB,IAAIoC,EACrB/D,KAAKmB,aACLwB,EACAX,EACAM,EACAF,EACAC,EACAQ,EACAW,EACAE,EACAE,GAEJ,YAGG,YAAAI,KAAP,W,MACsB,QAAlB,EAAAhE,KAAK2B,qBAAa,SAAEqC,QAGjB,YAAAC,KAAP,W,MACsB,QAAlB,EAAAjE,KAAK2B,qBAAa,SAAEsC,QAE5B,EAvFA,GA6FA,aAYI,WACIC,EACAvB,EACAX,EACAM,EACAF,EACAC,EACAQ,EACAW,EACAE,EACAE,GAEA5D,KAAKkE,MAAQA,EACblE,KAAK2C,OAASA,EACd3C,KAAKgC,OAASA,EACdhC,KAAKsC,SAAWA,EAChBtC,KAAKoC,qBAAuBA,EAC5BpC,KAAKqC,mBAAqBA,EAC1BrC,KAAK6C,eAAiBA,EACtB7C,KAAKwD,MAAQA,EACbxD,KAAK0D,SAAWA,EAChB1D,KAAK4D,KAAOA,EAyEpB,OAtEY,YAAAO,sBAAR,sBACIC,OAAOD,uBAAsB,WACzB,EAAK7B,SAAS+B,OAAO,EAAKb,MAAO,EAAKxB,YAItC,YAAAsC,0BAAR,WACItE,KAAKgC,OAAOuC,OACRvE,KAAKkE,MAAMM,aAAexE,KAAKkE,MAAMO,cACzCzE,KAAKgC,OAAO0C,yBACZ,IAAMC,EAAOpD,MAAMqD,KAAKC,SAAS7E,KAAKgC,OAAO8C,KACvCC,EAAY,EAAIH,KAAKI,IAAIL,EAAO,GAAK3E,KAAKgC,OAAOE,SAASC,EAG1DL,EAASiD,EACTnD,EAAQmD,GAFV/E,KAAKkE,MAAMO,cAAgBzE,KAAKkE,MAAMM,cAG1CxE,KAAK4D,KAAKqB,MAAMC,IAAItD,EAAOE,EAAQ,GACnC9B,KAAKmE,yBAGD,YAAAgB,iBAAR,SAAyBC,GACrB,IAAMC,EAAOrF,KAAK2C,OAAO2C,wBACnBC,EAAIX,KAAKY,KAAK,IAAKZ,KAAKa,IAAI,IAAKL,EAAMM,QAAUL,EAAKM,OACtDC,EAAIhB,KAAKY,KAAK,IAAKZ,KAAKa,IAAI,IAAKL,EAAMS,QAAUR,EAAKS,MAC5D9F,KAAK6C,eAAeE,SAASC,OAAOC,OAASsC,EAAI,KACjDvF,KAAK6C,eAAeE,SAASG,OAAOD,MAAQ2C,EAAI,KAChD5F,KAAK2C,OAAOoD,MAAMC,UAAY,qBAAqBT,EAAI,GAAE,OACzDvF,KAAKmE,yBAGF,YAAAH,KAAP,WACIhE,KAAK2C,OAAOoD,MAAME,QAAU,QAC5BjG,KAAKkE,MAAM6B,MAAME,QAAU,OACI,OAA3BjG,KAAK2C,OAAO3B,aACZhB,KAAKkE,MAAMlD,WAAWC,aAClBjB,KAAK2C,OAAQ3C,KAAKkE,MAAMhD,aAE5BlB,KAAKsC,SAASI,QACV1C,KAAK2C,OAAOd,YACZ7B,KAAK2C,OAAOZ,eAGpBqC,OAAO8B,iBACH,SACAlG,KAAKsE,0BAA0B6B,KAAKnG,OACpC,GAEJW,SAASuF,iBACL,YACAlG,KAAKmF,iBAAiBgB,KAAKnG,OAC3B,GAEJA,KAAKsE,4BACLtE,KAAKmE,yBAGF,YAAAF,KAAP,WACIjE,KAAKkE,MAAM6B,MAAME,QAAU,QAC3BjG,KAAK2C,OAAOoD,MAAME,QAAU,OAC5B7B,OAAOgC,oBACH,SACApG,KAAKsE,0BAA0B6B,KAAKnG,OACpC,GAEJW,SAASyF,oBACL,YACApG,KAAKmF,iBAAiBgB,KAAKnG,OAC3B,IAGZ,EA1GA,G,60CCtGAW,SAASuF,iBAAiB,oBAAoB,qD,gEA4B1C,OA3BMnG,EAA6BY,SAC9B0F,cAAc,iCAEbC,EAAc,IAAIC,EAAYxG,GAC9ByG,EAAwB7F,SACzB8F,iBAAmC,gBAClCC,EAAiBC,MAAMC,KAAKJ,GAC7BK,KAAI,SAACC,GAAY,WAAIC,EAAcD,MAoBxC,IAlBME,EAAyB,qD,qEACvBrG,SAASsG,gBAAgBpF,YAAc,MAAvC,YACA,IAAK,EAAL,EAA0B,EAAA6E,EAAA,eAAjBQ,EAAa,KAClBzF,QAAQC,IAAI,4BACZwF,EAAcjD,O,mBAIlB,OADAxC,QAAQC,IAAI,uBACZ,GAAM4E,EAAYrG,Q,OAAlB,S,IAC0B,EAAAyG,E,wBAAA,YAAjBQ,EAAa,KAClBzF,QAAQC,IAAI,6BACZ,GAAMwF,EAAcjH,SAFgB,M,OAEpC,SACAwB,QAAQC,IAAI,6BACZwF,EAAclD,O,wBAJQ,I,iDASlC,SACAI,OAAO8B,iBAAiB,SAAUc,GAAwB,G,kBCrE9DrG,SAASuF,iBAAiB,oBAAoB,SAASd,GACrD,IAAM+B,EAAmBxG,SAASC,eAAe,qBAC3CwG,EAAuBzG,SAASC,eAAe,0BAC/CyG,EAAU1G,SAASC,eAAe,gCAClC+B,EAA6BhC,SAASC,eAAe,wBACrD0G,EAAM3E,EAAO4E,WAAW,MAExBzF,EAASa,EAAOf,OAAS,KAAO,MACtCe,EAAOb,OAASA,EAEhB,IAAM0F,EAAQ,IAAIC,MAOlB,SAASC,EAASC,GAChB,MAAO,mDAAmDA,EAAK,QAPjEH,EAAM1G,OAAS,WACbwG,EAAIM,UAAU,EAAE,EAAEjF,EAAOf,MAAMe,EAAOb,QACtCwF,EAAIO,UAAUL,EAAO,EAAG,EAAGA,EAAM5F,MAAO4F,EAAM1F,OAChC,EAAG,EAAGa,EAAOf,MAAOe,EAAOb,SAO3C,IAAIgG,GAAqB,EAEzB,SAASC,IACP,IAAM1C,EAAO1C,EAAO2C,wBACd0C,EAAW,GAAK3C,EAAKO,EAAIxB,OAAO6D,cAAgB5C,EAAKvD,OAASsC,OAAO6D,aAC3E,KAAID,EAAW,GAAKA,EAAW,GAA/B,CAEA,IAAKF,EAAoB,CACvB,I,eAASI,GACP,IAAIhI,SAAQ,SAAAiI,GACV,IAAIjE,EAAQ,IAAIuD,MAChBvD,EAAMpD,OAASqH,EACfjE,EAAMkE,QAAUD,EAChBjE,EAAMnD,IAAM2G,EAASQ,OALhBA,EAAI,GAAIA,GAAK,IAAKA,I,EAAlBA,GAQTJ,GAAqB,EAEvB,IAAMO,EAAa,GAAKzD,KAAK0D,MAZN,GAYYN,GACnCR,EAAMzG,IAAM2G,EAASW,IAGvB,SAASE,IACP,IAAMlD,EAAO8B,EAAiB7B,wBACxB0C,EAAW,GAAK3C,EAAKO,EAAIxB,OAAO6D,cAAgB5C,EAAKvD,OAASsC,OAAO6D,aACvED,EAAW,GAAKA,EAAW,IAC/BZ,EAAqBoB,UAAuB,IAAXR,GAGnC,SAASS,IACH9H,SAASsG,gBAAgBpF,YAAc,MACzCc,EAAOoD,MAAME,QAAU,OACvBoB,EAAQtB,MAAME,QAAU,QACxB7B,OAAOgC,oBAAoB,SAAU2B,GAA8B,GAEnE3D,OAAOgC,oBAAoB,SAAUmC,GAAkB,KAEvDlB,EAAQtB,MAAME,QAAU,OACxBtD,EAAOoD,MAAME,QAAU,QACvB8B,IACA3D,OAAO8B,iBAAiB,SAAU6B,GAA8B,GAChEQ,IACAnE,OAAO8B,iBAAiB,SAAUqC,GAAkB,IAIxDE,IACArE,OAAO8B,iBAAiB,SAAUuC,GAAmB","file":"index.min.js","sourcesContent":["/**\n * A lazy loader for the THREE.js script.\n *\n * Usage:\n *\n * ```typescript\n * const linkElement = <HTMLLinkElement>document\n *     .querySelector('link[rel=\"parallax-three-js\"]')\n * // TODO: Check if linkElement actually exists\n * const loader = new ThreeLoader(linkElement)\n *     .load(() => {\n *         // Do something on load\n *     })\n * ```\n */\nexport class ThreeLoader {\n    private threeLink: HTMLLinkElement\n\n    public constructor(threeLink: HTMLLinkElement) {\n        this.threeLink = threeLink\n    }\n\n    /**\n     * Load THREE.js into a script element.\n     *\n     * The script element is placed below the given link element.\n     * See index.ts for a usage example.\n     */\n    public async load(): Promise<HTMLScriptElement> {\n        return new Promise((resolve, reject) => {\n            const id = this.threeLink.getAttribute('data-id')\n            if (id === undefined) {\n                reject(new Error(\n                    'The link element has to supply a data-id attribute!'\n                ))\n            }\n\n            const href = this.threeLink.getAttribute('href')\n            if (href === undefined) {\n                reject(new Error(\n                    'The link element has to supply a href attribute!'\n                ))\n            }\n\n            // Check if there is already a THREE.js script element.\n            let threeElement = <HTMLScriptElement>\n                document.getElementById(id)\n            if (threeElement !== null) {\n                resolve(threeElement)\n                return\n            }\n\n            // If not, create a new one.\n            threeElement = document.createElement('script')\n            threeElement.onload = () => {\n                resolve(threeElement)\n            }\n            threeElement.id = id\n            threeElement.src = href\n            // Insert THREE.js after the link element.\n            this.threeLink.parentNode.insertBefore(\n                threeElement, this.threeLink.nextSibling\n            )\n        })\n    }\n}\n","/**\n * The lazily imported THREE.js library.\n *\n * THREE is loaded lazily and only on devices exceeding a given\n * maximum width. It will not be included as a module to reduce the\n * file size of this script.\n */\ndeclare var THREE: any\n\n/**\n * The vertex shader for the THREE.js web gl renderer.\n */\nconst vertexShader: String = `\n    varying vec2 vUv;\n\n    void main()\t{\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n`\n\n\n/**\n * The fragment shader for the THREE.js web gl renderer.\n */\nconst fragmentShader: String = `\n    #extension GL_OES_standard_derivatives : enable\n    varying vec2 vUv;\n    uniform float mouseX;\n    uniform float mouseY;\n    uniform float scrollOffset;\n    uniform sampler2D depthTexture;\n    uniform sampler2D texture;\n    void main() {\n        vec2 vMouse = vec2(mouseX, mouseY);\n        vec2 vScrollOffset = vec2(0, scrollOffset);\n        float depth = texture2D(depthTexture, vUv).r;\n        gl_FragColor = texture2D(\n            texture, vUv + vMouse * (depth) + vScrollOffset\n        );\n        // Do some edge anti aliasing, because the image\n        // may contain a premultiplied alpha channel.\n        gl_FragColor.rgb = gl_FragColor.rgb * gl_FragColor.a;\n    }\n`\n\n/**\n * A parallax image, driven by THREE.js.\n */\nexport class ParallaxImage {\n    imageElement: HTMLImageElement\n\n    parallaxScene?: ParallaxScene\n\n    public constructor(imageElement: HTMLImageElement) {\n        this.imageElement = imageElement\n    }\n\n    public async loadTextureBehindAttribute(attribute: string): Promise<any> {\n        return new Promise((resolve, reject) => {\n            const src = this.imageElement.getAttribute(attribute)\n            if (src === null) {\n                reject(new Error(`\n                    The image element must include\n                    an attribute \"${attribute}\"!\n                `))\n                return\n            }\n            const textureLoader = new THREE.TextureLoader()\n                .load(src, () => {\n                    console.log(`Loaded image resource ${src}`)\n                    resolve(textureLoader)\n                })\n        })\n    }\n\n\n    public async load() {\n        if (this.parallaxScene !== undefined) {\n            return\n        }\n\n        const width = this.imageElement.clientWidth\n        const height = this.imageElement.clientHeight\n        const camera = new THREE.PerspectiveCamera(\n            45, width / height, 1, 1000\n        )\n        camera.position.z = 200\n        const diffuseTextureLoader = await this\n            .loadTextureBehindAttribute('src')\n        const depthTextureLoader = await this\n            .loadTextureBehindAttribute('data-parallax-depth-map')\n        const renderer = new THREE.WebGLRenderer({\n            antialias: true,\n            alpha: true\n        })\n        renderer.setSize(width, height)\n        const canvas = renderer.domElement\n        const shaderMaterial = new THREE.ShaderMaterial({\n            uniforms: {\n                mouseX: {value: 0},\n                mouseY: {value: 0},\n                scrollOffset: {value: 0},\n                texture: {value: diffuseTextureLoader},\n                depthTexture: {value: depthTextureLoader},\n            },\n            vertexShader,\n            fragmentShader\n        })\n        const scene = new THREE.Scene()\n        const geometry = new THREE.PlaneBufferGeometry(1, 1)\n        const mesh = new THREE.Mesh(geometry, shaderMaterial)\n        scene.add(mesh)\n\n        this.parallaxScene = new ParallaxScene(\n            this.imageElement,\n            canvas,\n            camera,\n            renderer,\n            diffuseTextureLoader,\n            depthTextureLoader,\n            shaderMaterial,\n            scene,\n            geometry,\n            mesh\n        )\n        return\n    }\n\n    public show(): void {\n        this.parallaxScene?.show()\n    }\n\n    public hide(): void {\n        this.parallaxScene?.hide()\n    }\n}\n\n\n/**\n * A parallax scene, driven by THREE.js.\n */\nclass ParallaxScene {\n    image: HTMLImageElement\n    canvas: HTMLCanvasElement\n    camera: any\n    renderer: any\n    diffuseTextureLoader: any\n    depthTextureLoader: any\n    shaderMaterial: any\n    scene: any\n    geometry: any\n    mesh: any\n\n    public constructor(\n        image: HTMLImageElement,\n        canvas: HTMLCanvasElement,\n        camera: any,\n        renderer: any,\n        diffuseTextureLoader: any,\n        depthTextureLoader: any,\n        shaderMaterial: any,\n        scene: any,\n        geometry: any,\n        mesh: any\n    ) {\n        this.image = image\n        this.canvas = canvas\n        this.camera = camera\n        this.renderer = renderer\n        this.diffuseTextureLoader = diffuseTextureLoader\n        this.depthTextureLoader = depthTextureLoader\n        this.shaderMaterial = shaderMaterial\n        this.scene = scene\n        this.geometry = geometry\n        this.mesh = mesh\n    }\n\n    private requestAnimationFrame(): void {\n        window.requestAnimationFrame(() => {\n            this.renderer.render(this.scene, this.camera)\n        })\n    }\n\n    private updateViewportAspectRatio(): void {\n        this.camera.aspect =\n            this.image.naturalWidth / this.image.naturalHeight\n        this.camera.updateProjectionMatrix()\n        const vFOV = THREE.Math.degToRad(this.camera.fov)\n        const maxHeight = 2 * Math.tan(vFOV / 2) * this.camera.position.z\n        const imageAspect =\n            this.image.naturalHeight / this.image.naturalWidth\n        const height = maxHeight\n        const width = maxHeight * imageAspect\n        this.mesh.scale.set(width, height, 1)\n        this.requestAnimationFrame()\n    }\n\n    private reactToMouseMove(event: MouseEvent): void {\n        const rect = this.canvas.getBoundingClientRect()\n        const x = Math.max(-500, Math.min(500, event.clientX - rect.left))\n        const y = Math.max(-500, Math.min(500, event.clientY - rect.top))\n        this.shaderMaterial.uniforms.mouseX.value = -x / 15000\n        this.shaderMaterial.uniforms.mouseY.value = y / 15000\n        this.canvas.style.transform = `rotate3d(0, 1, 1, ${x / 50}deg)`\n        this.requestAnimationFrame()\n    }\n\n    public show(): void {\n        this.canvas.style.display = 'block'\n        this.image.style.display = 'none'\n        if (this.canvas.parentNode === null) {\n            this.image.parentNode.insertBefore(\n                this.canvas, this.image.nextSibling\n            )\n            this.renderer.setSize(\n                this.canvas.clientWidth,\n                this.canvas.clientHeight\n            )\n        }\n        window.addEventListener(\n            'resize',\n            this.updateViewportAspectRatio.bind(this),\n            true\n        )\n        document.addEventListener(\n            'mousemove',\n            this.reactToMouseMove.bind(this),\n            true\n        )\n        this.updateViewportAspectRatio()\n        this.requestAnimationFrame()\n    }\n\n    public hide(): void {\n        this.image.style.display = 'block'\n        this.canvas.style.display = 'none'\n        window.removeEventListener(\n            'resize',\n            this.updateViewportAspectRatio.bind(this),\n            true\n        )\n        document.removeEventListener(\n            'mousemove',\n            this.reactToMouseMove.bind(this),\n            true\n        )\n    }\n}\n","/**\n * Author: Philipp Matthes\n *\n * This module is used for a parallax effect on images.\n *\n * It uses THREE.js (https://threejs.org/) on a canvas\n * together with an image and a depth map to apply\n * parallax occlusion mapping, similar to the\n * 3Dify app (https://github.com/3dify-app).\n *\n * Usage:\n *\n * ```html\n * <!-- Somewhere in your html --!>\n * <img ... src=\"path/to/preview.webp\"\n *          class=\"parallax\"\n *          data-parallax-depth-map=\"path/to/preview-depth.webp\">\n * <!-- Preferably at the bottom of your body element --!>\n * <link rel=\"parallax-three-js\"\n *       href=\"path/to/three.min.js\"\n *       data-id=\"id-of-the-lazyloaded-three-script-element\">\n * <!-- THREE.js will be loaded lazily to this location --!>\n * ```\n *\n * Notes:\n * - The srcset attribute is not supported.\n * - The image element gets lazily replaced (only on devices\n * wider than 1023 pixels) by a canvas which will render a\n * THREE.js parallax scene with the given depth map.\n * - THREE.js and the parallax effect is only loaded, when the\n * screen exceeds mobile device width of 1023 pixels. This also\n * applies to screen resizing events and not only the initial\n * page load.\n */\n\n\nimport { ThreeLoader } from './loader'\nimport { ParallaxImage } from './image'\n\n\ndocument.addEventListener(\"DOMContentLoaded\", async () => {\n    const threeLink = <HTMLLinkElement>document\n        .querySelector('link[rel=\"parallax-three-js\"]')\n\n    const threeLoader = new ThreeLoader(threeLink)\n    const parallaxImageElements = document\n        .querySelectorAll<HTMLImageElement>('img.parallax')\n    const parallaxImages = Array.from(parallaxImageElements)\n        .map((element) => new ParallaxImage(element))\n\n    const updateWindowDimensions = async () => {\n        if (document.documentElement.clientWidth < 1023) {\n            for (let parallaxImage of parallaxImages) {\n                console.log('Hiding parallax image...')\n                parallaxImage.hide()\n            }\n        } else {\n            console.log('Loading THREE.js...')\n            await threeLoader.load()\n            for (let parallaxImage of parallaxImages) {\n                console.log('Loading parallax image...')\n                await parallaxImage.load()\n                console.log('Showing parallax image...')\n                parallaxImage.show()\n            }\n        }\n    }\n\n    await updateWindowDimensions()\n    window.addEventListener('resize', updateWindowDimensions, false)\n})\n\n","document.addEventListener(\"DOMContentLoaded\", function(event) {\n  const macbookContainer = document.getElementById('macbook-container');\n  const macbookCodeContainer = document.getElementById('macbook-code-container');\n  const preview = document.getElementById('peerbridge-animation-preview');\n  const canvas = <HTMLCanvasElement> document.getElementById('peerbridge-animation');\n  const ctx = canvas.getContext('2d');\n\n  const height = canvas.width * (2541 / 2225);\n  canvas.height = height;\n\n  const frame = new Image();\n  frame.onload = function() {\n    ctx.clearRect(0,0,canvas.width,canvas.height)\n    ctx.drawImage(frame, 0, 0, frame.width, frame.height, // source rectangle\n                  0, 0, canvas.width, canvas.height); // destination rectangle\n  }\n\n  function frameURL(index: Number) {\n    return `/static/img/peerbridge-animation/animation-1000_${index}.webp`;\n  }\n\n  let hasPreloadedFrames = false;\n\n  function updateCurrentPeerbridgeFrame() {\n    const rect = canvas.getBoundingClientRect();\n    const progress = 1 - (rect.y + window.innerHeight) / (rect.height + window.innerHeight);\n    if (progress > 1 || progress < 0) return;\n    const numberOfFrames = 120 - 38;\n    if (!hasPreloadedFrames) {\n      for (let i = 38; i <= 120; i++) {\n        new Promise(r => {\n          var image = new Image();\n          image.onload = r;\n          image.onerror = r;\n          image.src = frameURL(i);\n        });\n      }\n      hasPreloadedFrames = true;\n    }\n    const frameIndex = 38 + Math.round(progress * numberOfFrames);\n    frame.src = frameURL(frameIndex);\n  }\n\n  function updateCodeScroll() {\n    const rect = macbookContainer.getBoundingClientRect();\n    const progress = 1 - (rect.y + window.innerHeight) / (rect.height + window.innerHeight);\n    if (progress > 1 || progress < 0) return;\n    macbookCodeContainer.scrollTop = progress * 1000;\n  }\n\n  function updateDeviceWidth() {\n    if (document.documentElement.clientWidth < 1023) {\n      canvas.style.display = 'none';\n      preview.style.display = 'block';\n      window.removeEventListener('scroll', updateCurrentPeerbridgeFrame, true);\n\n      window.removeEventListener('scroll', updateCodeScroll, true);\n    } else {\n      preview.style.display = 'none';\n      canvas.style.display = 'block';\n      updateCurrentPeerbridgeFrame();\n      window.addEventListener('scroll', updateCurrentPeerbridgeFrame, true);\n      updateCodeScroll();\n      window.addEventListener('scroll', updateCodeScroll, true);\n    }\n  }\n\n  updateDeviceWidth();\n  window.addEventListener('resize', updateDeviceWidth, false);\n});\n"],"sourceRoot":""}